## let

### 暂时性死区

### 

## 块级作用域

#### 内层变量可能会覆盖外层变量
#### 用来计数的循环变量泄露为全局变量
#### ES6 允许块级作用域的任意嵌套
### 函数能不能在块级作用域之中声明（ES5） --- ES6 引入了块级作用域，明确允许在块级作用域之中声明函数
ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。

但在 ES6 浏览器中，都会报错。原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。

#### ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。

#### 函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层

## const

const一旦声明变量，就必须立即初始化，不能留到以后赋值。

const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。

### ES6 声明变量的六种方法
ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import 命令和 class 命令。所以，ES6 一共有 6 种声明变量的方法。

### 顶层对象的属性
顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。
```
window.a = 1;
a // 1

a = 2;
window.a // 2
```
上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事

注意：顶层对象的利弊  ====》 ES6 为了改变这一点，一方面规定，为了保持兼容性，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。（也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。）

### globalThis 对象
JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。